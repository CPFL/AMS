<!DOCTYPE html>
<html lang="jp">
    <head>
        <title>SimAutowareViewer</title>
        <link rel="icon" href="./static/ico/autoware_icon.ico">
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                color: #cccccc;
                font-family:Monospace;
                font-size:13px;
                text-align:center;

                background-color: #000000;
                margin: 0px;
                overflow: hidden;
            }

            #info {
                position: absolute;
                top: 0px; width: 100%;
                padding: 5px;
            }

            a {
                color: #0080ff;
            }

        </style>

        <!-- MQTT -->
        <script src="./static/js/mqtt/mqtt.min.js" type="text/javascript"></script>

        <!-- ThreeJS -->
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <script src="./static/js/threejs/Detector.js"></script>
        <script src="./static/js/threejs/stats.min.js"></script>
        <script src="./static/js/threejs/three.js"></script>
        <script src="./static/js/threejs/OrbitControls.js"></script>
        <script src="./static/js/threejs/PCDLoader.js"></script>
        <script src="./static/js/threejs/ColladaLoader.js"></script>
        <script src="./static/js/threejs/TDSLoader.js"></script>
        <script src="./static/js/threejs/GeometryUtils.js"></script>
        <script src="./static/js/threejs/WebGLDeferredRenderer.js"></script>

    </head>
    <body>

        <!--<div id="container"></div>-->

        <script language="JavaScript">
            const VERSION = "0.3";
            const print = console.info;
            const time = function() {
                const date = new Date();
                return Math.floor( date.getTime() / 1000 )
            };

            const TOPIC = {
                DELIMITER: "/",
                ANY: "*"
            };
            class Topic {

                static get_domain(topic) {
                    return topic.split("/")[1]
                }

                static get_from_name(topic) {
                    return topic.split("/")[2]
                }

                static get_from_id(topic) {
                    return topic.split("/")[3]
                }

                static get_to_name(topic) {
                    return topic.split("/")[4]
                }

                static get_to_id(topic) {
                    return topic.split("/")[5]
                }

                static get_categories(topic) {
                    return topic.split("/").slice(6)
                }

                static get_categories_code(topic) {
                    return Topic.get_categories(topic).join("/")
                }

                static get_from_target_code(topic) {
                    return [this.get_from_name(topic), this.get_from_id(topic)].join("/")
                }

                static compare_topics(subscribe_topic, incoming_topic) {
                    if (subscribe_topic === incoming_topic) return true;
                    else {
                        const subscribe_topic_parts = subscribe_topic.split(TOPIC.DELIMITER);
                        const incoming_topic_parts = incoming_topic.split(TOPIC.DELIMITER);
                        for(const i in subscribe_topic_parts) {
                            const subscribe_topic_part = subscribe_topic_parts[i];
                            if (subscribe_topic_part === "#") {
                                return true;
                            }
                            else {
                                if(
                                    subscribe_topic_part !== incoming_topic_parts[i] &&
                                    subscribe_topic_part !== "+" &&
                                    TOPIC.ANY !== incoming_topic_parts[i] ) {
                                    return false;
                                }
                            }
                        }
                    }
                    return true;
                }
            }

            class PubSubClient {

                constructor() {
                    this.topics = [];
                    this.onMessageCallbacks = {};
                    this.client  = mqtt.connect('mqtt://localhost:8080');
                }

                setOnMessageCallback(topic, onMessageCallback) {
                    this.topics.push(topic);
                    this.onMessageCallbacks[topic] = onMessageCallback;
                }

                publish(topic, message) {
                    this.client.publish(topic, JSON.stringify(message));
                }

                start() {
                    const that = this;
                    this.client.on('connect', function () {
                        for(const topic of that.topics) {
                            that.client.subscribe(topic);
                        }
                    });
                    this.client.on('message', function (topic, message) {
                        for(const subscribe_topic of that.topics) {
                            if( Topic.compare_topics(subscribe_topic, topic) ) {
                                that.onMessageCallbacks[subscribe_topic](topic, JSON.parse(message.toString()));
                            }
                        }
                    });
                }
            }

            class ThreeMap {

                constructor() {
                    this.amsObjects = {
                        "maps": {},
                        "pcd": {},
                        "waypoint": {},
                        "line": {},
                        "arrowHelper": {},
                        "vehicle": {},
                        "shutter": {},
                        "light": {}
                    };
                    this.container = document.createElement( 'div' );
                    document.body.appendChild(this.container);

                    if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
                    this.manager = new THREE.LoadingManager();
                    this.fontLoader = new THREE.FontLoader();
                    this.colladaLoader = new THREE.ColladaLoader(this.manager);
                    this.tdsLoader = new THREE.TDSLoader(this.manager);

                    this.controls = null;

                    this.raycaster = new THREE.Raycaster();
                    this.mouse = new THREE.Vector2();
                    this.INTERSECTED = null;

                    this.camera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 1, 4000 );
                    this.camera.up.set(0,0,1);

                    this.scene = new THREE.Scene();

                    this.renderer = new THREE.WebGLRenderer( { antialias: false } );
                    this.renderer.setPixelRatio( window.devicePixelRatio );
                    this.renderer.setSize( window.innerWidth, window.innerHeight );
                    this.renderer.gammaInput = true;
                    this.renderer.gammaOutput = true;
                    this.renderer.setClearColor(new THREE.Color(0x333333), 1.0);
                    this.container.appendChild( this.renderer.domElement );

                    this.stats = new Stats();
                    this.container.appendChild( this.stats.dom );

                    this.setOrbitControls();

                    document.addEventListener( 'click', this.onDocumentMouseMove.bind(this), false );
                    window.addEventListener( 'resize', this.onWindowResize.bind(this), false );

                    this.scene.add( this.camera );

                    const light = new THREE.AmbientLight(new THREE.Color(0xFFFFFF), 0.75);
                    this.scene.add(light);

                    this.animate();

                    this.pubSubClient = new PubSubClient();
                    this.pubSubClient.setOnMessageCallback('/+/+/+/+/+/current_pose', this.onCurrentPoseMessage.bind(this));
                    this.pubSubClient.setOnMessageCallback('/+/+/+/+/+/decision_maker/state', this.onDecisionMakerStateMessage.bind(this));
                    this.pubSubClient.setOnMessageCallback('/+/shutter/+/+/+/response/get_config', this.onShutterConfigMessage.bind(this));
                    this.pubSubClient.setOnMessageCallback('/+/shutter/+/+/+/status', this.onShutterStatusMessage.bind(this));
                    this.pubSubClient.setOnMessageCallback('/+/light/+/+/+/response/get_config', this.onLightConfigMessage.bind(this));
                    this.pubSubClient.setOnMessageCallback('/+/light/+/+/+/status', this.onLightStatusMessage.bind(this));
                }

                setOrbitControls() {
                    this.controls = new THREE.OrbitControls( this.camera, this.renderer.domElement );
                    this.controls.screenSpacePanning = true;
                    this.controls.addEventListener( 'change', this.render.bind(this) );
                }

                animate() {
                    if( this.camera !== null && this.controls !==null ) {
                        this.updateTextFacing();
                        this.updateLightAngle();
                        requestAnimationFrame( this.animate.bind(this) );
                        this.render();
                        this.stats.update();
                    }
                }

                updateLightAngle() {
                    for( const lightObjectName in this.amsObjects.light ) {
                        const lightObject = this.amsObjects.light[lightObjectName];
                        if(
                            typeof lightObject !== "undefined" &&
                            lightObject !== null
                        ) {
                            if (
                                lightObject.spotLights !== null &&
                                lightObject.status !== null
                            ) {
                                if (lightObject.status.state === "on") {
                                    const spotLights = lightObject.spotLights;
                                    const date = new Date();
                                    const ms = date.getTime() / 100;
                                    spotLights[0].target.position.set(
                                        spotLights[0].position.x + Math.cos(ms),
                                        spotLights[0].position.y + Math.sin(ms),
                                        spotLights[0].position.z
                                    );
                                    spotLights[1].target.position.set(
                                        spotLights[1].position.x + Math.cos(ms + Math.PI),
                                        spotLights[1].position.y + Math.sin(ms + Math.PI),
                                        spotLights[1].position.z
                                    );
                                }
                            }
                        }
                    }
                }

                updateTextFacing() {
                    for( const textSceneObjectName in this.amsObjects.vehicle ) {
                        const textSceneObject = this.amsObjects.vehicle[textSceneObjectName].text;
                        if( typeof textSceneObject !== "undefined" && textSceneObject !== null ) {
                            const colladaSceneObject = this.amsObjects.vehicle[textSceneObjectName].collada;
                            if (colladaSceneObject !== null) {
                                const centerOffset = -0.5 * (textSceneObject.geometry.boundingBox.max.x - textSceneObject.geometry.boundingBox.min.x);
                                textSceneObject.position.x = colladaSceneObject.position.x + centerOffset;
                                textSceneObject.position.y = colladaSceneObject.position.y;
                                textSceneObject.position.z = colladaSceneObject.position.z + 2.0;
                                textSceneObject.lookAt(this.camera.position);
                            }
                        }
                    }
                }


                render() {
                    this.camera.updateMatrixWorld();
                    this.raycaster.setFromCamera( this.mouse, this.camera );
                    // var intersects = this.raycaster.intersectObjects( this.scene.children );
                    var intersects = this.raycaster.intersectObjects( Object.values(this.amsObjects.waypoint) );

                    if ( intersects.length > 0 ) {
                        // print(intersects);
                        if ( this.INTERSECTED !== intersects[ 0 ].object ) {
                            if ( this.INTERSECTED ) this.INTERSECTED.material.color.setHex( this.INTERSECTED.currentHex );
                            this.INTERSECTED = intersects[ 0 ].object;
                            print(this.INTERSECTED.userData);
                            this.INTERSECTED.currentHex = this.INTERSECTED.material.color.getHex();
                            this.INTERSECTED.material.color.setHex( 0x00FF00 );
                        }
                    } else {
                        if ( this.INTERSECTED ) this.INTERSECTED.material.color.setHex( this.INTERSECTED.currentHex );
                        this.INTERSECTED = null;
                    }

                    this.renderer.render( this.scene, this.camera );
                }

                onDocumentMouseMove( event ) {
                    event.preventDefault();
                    this.mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                    this.mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
                }

                onWindowResize() {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize( window.innerWidth, window.innerHeight );
                }

                updateViewPoseByTargetPosition(position) {
                    this.controls.target.set( position.x, position.y, position.z);
                    this.camera.position.x = position.x + 25;
                    this.camera.position.y = position.y + 20;
                    this.camera.position.z = position.z + 80;
                    this.camera.lookAt(this.controls.target);
                }

                getViewTargetPosition() {
                    let that = this;
                    const xhttpPCDs = new XMLHttpRequest();
                    xhttpPCDs.onreadystatechange = function() {
                        if (this.readyState == 4 && this.status == 200) {
                            that.updateViewPoseByTargetPosition(JSON.parse(this.responseText));
                        }
                    };
                    xhttpPCDs.open("GET", "http://"+location.host+"/get/view/target/position", true);
                    xhttpPCDs.send();
                }

                getAMSMaps() {
                    let that = this;
                    const xhttpPCDs = new XMLHttpRequest();
                    xhttpPCDs.onreadystatechange = function() {
                        if (this.readyState == 4 && this.status == 200) {
                            that.amsObjects["maps"] = JSON.parse(this.responseText);
                            that.drawArrows();
                        }
                    };
                    xhttpPCDs.open("GET", "http://"+location.host+"/get/ams/maps", true);
                    xhttpPCDs.send();
                }

                getPCDFileNames() {
                    let that = this;
                    const xhttpPCDs = new XMLHttpRequest();
                    xhttpPCDs.onreadystatechange = function() {
                        if (this.readyState == 4 && this.status == 200) {
                            that.getPointsMap(JSON.parse(this.responseText), that.scene, 0.1);
                        }
                    };

                    xhttpPCDs.open("GET", "http://"+location.host+"/get/pcd/file/names", true);
                    xhttpPCDs.send();
                }

                getPointsMap(pcdFileNames, scene, pointSize=0.1) {
                    let loader = new THREE.PCDLoader();
                    this.amsObjects["pcd"] = {};
                    const that = this;
                    for(const pcdFileName of pcdFileNames) {
                        const url = "http://"+location.host+"/get/pcd/file/"+pcdFileName;
                        loader.load(
                            url,
                            function ( mesh ) {
                                mesh.name = url;
                                // mesh.material = new THREE.MeshLambertMaterial();
                                // mesh.material.size = 5;
                                mesh.material.size = pointSize;
                                // mesh.material.lights = true;
                                // mesh.material.color.setHex(0xffffff);
                                that.amsObjects["pcd"][url] = mesh;
                                scene.add(that.amsObjects["pcd"][url]);
                            },
                            // called when loading is in progresses
                            function ( xhr ) {
                                //print( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
                            },
                            // called when loading has errors
                            function ( error ) {
                                print( 'An error happened', error );
                            }
                        );
                    }
                }

                drawArrows() {
                    const color = new THREE.Color(0xFF0000);
                    var material = new THREE.LineBasicMaterial({ color: color, linewidth: 5 });
                    for(const arrow of Object.values(this.amsObjects.maps.arrows)) {
                        var geometry = new THREE.Geometry();
                        for(const waypointID of Object.values(arrow.waypointIDs)) {
                            const point = this.amsObjects.maps.waypoints[waypointID];
                            geometry.vertices.push(new THREE.Vector3(point.position.x, point.position.y, point.position.z));

                            const sphere = new THREE.SphereBufferGeometry( 0.05, 16, 8 );
                            const waypoint = new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( {
                                color: color
                            }));
                            waypoint.position.set(point.position.x, point.position.y, point.position.z);
                            waypoint.userData = {
                                waypointID: waypointID,
                                arrowCode: arrow.arrowCode
                            };
                            this.amsObjects["waypoint"][waypointID] = waypoint;
                            this.scene.add( this.amsObjects["waypoint"][waypointID] );

                        }
                        geometry.computeBoundingSphere();

                        const line = new THREE.Line( geometry, material );
                        line.name = arrow.arrowCode;
                        this.amsObjects["line"][arrow.arrowCode] = line;
                        this.scene.add( this.amsObjects["line"][arrow.arrowCode] );

                        var to = geometry.vertices[geometry.vertices.length-1];
                        var from = geometry.vertices[geometry.vertices.length-2];
                        var direction = to.clone().sub(from);
                        const headLength = 1.0;
                        const headWidth = 0.5;
                        var arrowHelper = new THREE.ArrowHelper(direction.normalize(), to, headLength+0.00000001, color, headLength, headWidth);
                        arrowHelper.name = "arrowHead/"+arrow.arrowCode;
                        this.amsObjects["arrowHelper"][arrow.arrowCode] = arrowHelper;
                        this.scene.add( this.amsObjects["arrowHelper"][arrow.arrowCode] );

                    }
                }

                onCurrentPoseMessage(topic, message) {
                    const currentPose = message;
                    const sceneObjectName = Topic.get_from_target_code(topic);
                    const to_name = Topic.get_to_name(topic);
                    let daeFileName = "milee_proto_reduced_nolight.dae";
                    if( to_name.includes("milee") ) {
                        daeFileName = "milee_proto_reduced_nolight.dae"
                    }
                    else if( to_name.includes("logiee") ) {
                        daeFileName = "logiee.dae"
                    }
                    else if( to_name.includes("postee") ) {
                        daeFileName = "milee_proto_reduced_nolight.dae"
                    }
                    const sceneObject = this.amsObjects.vehicle[sceneObjectName];
                    const that = this;
                    if(typeof sceneObject === "undefined") {
                        this.amsObjects.vehicle[sceneObjectName] = {"collada": null, "text": null};
                        this.colladaLoader.load(
                            "http://"+location.host+"/static/dae/"+daeFileName,
                            function ( collada ) {
                                collada.scene.name = sceneObjectName;
                                that.amsObjects.vehicle[sceneObjectName].collada = collada.scene;
                                that.scene.add(that.amsObjects.vehicle[sceneObjectName].collada);
                                that.updateCollada(that.amsObjects.vehicle[sceneObjectName].collada, currentPose);
                            }
                        );
                    }
                    else if ( sceneObject.collada !== null ) {
                        this.updateCollada(sceneObject.collada, currentPose);
                        // this.updateViewPoseByTargetPosition(currentPose.pose.position);
                    }
                }

                onDecisionMakerStateMessage(topic, message) {
                    const decisionMakerState = message.data;
                    const vehicleName = Topic.get_from_target_code(topic);
                    const that = this;
                    this.fontLoader.load("http://"+location.host+'/static/json/helvetiker_regular.typeface.json', function(font) {
                        const sceneObject = that.amsObjects.vehicle[vehicleName];
                        if( typeof sceneObject === "undefined" ) return;
                        if( sceneObject.collada === null ) return;

                        let stateSceneObject = that.amsObjects.vehicle[vehicleName].text;
                        if(stateSceneObject !== null) {
                            if( stateSceneObject.geometry.parameters.text === decisionMakerState ) {
                                stateSceneObject.lookAt( that.camera.position );
                                return;
                            }
                            else that.scene.remove(stateSceneObject);
                        }

                        let color = null;
                        if(decisionMakerState.includes("\nWaitOrder\n")){
                            color = new THREE.Color(0xFF0000);
                        }
                        else if(decisionMakerState.includes("\nDriveReady\n")){
                            color = new THREE.Color(0x11CCFF);
                        }
                        else if(decisionMakerState.includes("\nDriving\n")){
                            color = new THREE.Color(0x22FF00);
                        }
                        else {
                                color = new THREE.Color(0xFFFFFF);
                        }
                        const textMaterial = new THREE.MeshBasicMaterial({color: color, overdraw: 0.2});
                        const textGeometry = new THREE.TextGeometry(
                            decisionMakerState,
                            {
                                font: font,
                                size: 0.2,
                                height: 0,
                                curveSegments: 1
                            });
                        textGeometry.computeBoundingBox();
                        stateSceneObject = new THREE.Mesh(textGeometry, textMaterial);
                        stateSceneObject.name = vehicleName;
                        stateSceneObject.up.set(0,0,1);
                        that.amsObjects.vehicle[vehicleName].text = stateSceneObject;
                        that.scene.add(that.amsObjects.vehicle[vehicleName].text);
                    });
                }

                updateCollada(collada, currentPose) {
                    collada.position.x = currentPose.pose.position.x;
                    collada.position.y = currentPose.pose.position.y;
                    collada.position.z = currentPose.pose.position.z;
                    collada.setRotationFromQuaternion(currentPose.pose.orientation);
                }

                onLightStatusMessage(topic, message) {
                    const name = Topic.get_from_target_code(topic);
                    const object = this.amsObjects.light[name];
                    if(typeof object === "undefined") {
                        const domain = Topic.get_domain(topic);
                        this.requestLightConfig(domain, name);
                    }
                    else {
                        if(object.spotLights !== null) {
                            this.updateLightStatus(object, message);
                        }
                    }
                }

                requestLightConfig(domain, from_target_code) {
                    const requestTopic = ["", domain, "dev_front/df1", from_target_code, "request/get_config"].join("/");
                    const message = {
                        "header": {
                            "id": "",
                            "time": time(),
                            "version": VERSION
                        }
                    };
                    this.pubSubClient.publish(requestTopic, message);
                }

                onLightConfigMessage(topic, message) {
                    const lightConfig = message;
                    const name = Topic.get_from_target_code(topic);
                    const lightObject = this.amsObjects.light[name];
                    if(typeof lightObject === "undefined") {
                        this.amsObjects.light[name] = {
                            "config": lightConfig,
                            "status": null,
                            "scene": null,
                            "spotLights": null
                        };
                        this.addLight(
                            "static/3ds/patlite.3ds", name, lightConfig.body.pose.position,
                            {
                                "x": 0.005, "y": 0.005, "z": 0.005
                            },
                            0.0
                        );
                    }
                }

                addLight(path, name, position, scale) {
                    const that = this;
                    this.tdsLoader.load(path, function (object) {
                        const spotLight1 = new THREE.SpotLight(new THREE.Color(0xFF9999), 3, 1.0, Math.PI*2/3, 0, 3);
                        spotLight1.position.set(position.x, position.y, position.z+0.5);
                        const spotLight2 = new THREE.SpotLight(new THREE.Color(0xFF9999), 3, 1.0, Math.PI*2/3, 0, 3);
                        spotLight2.position.set(position.x, position.y, position.z+0.5);

                        const backMaterial = new THREE.MeshPhysicalMaterial( {
                            map: null,
                            color: new THREE.Color(0xff0000),
                            metalness: 1.0,
                            roughness: 0.5,
                            opacity: 0.75,
                            side: THREE.BackSide,
                            transparent: true,
                            premultipliedAlpha: true
                        } );
                        const frontMaterial = new THREE.MeshPhysicalMaterial( {
                            map: null,
                            color: new THREE.Color(0xff0000),
                            metalness: 0.0,
                            roughness: 0,
                            opacity: 0.25,
                            side: THREE.FrontSide,
                            transparent: true,
                            premultipliedAlpha: true
                        } );

                        object.add(object.children[0].clone());
                        object.children[0].material = backMaterial;
                        object.children[1].material.side = THREE.DoubleSide;
                        object.children[1].material.color = new THREE.Color(0x555555);
                        object.children[2].material = frontMaterial;
                        object.scale.set(scale.x, scale.y, scale.z);
                        object.position.set(position.x, position.y, position.z);
                        object.name = name;
                        that.amsObjects.light[name].scene = object;
                        that.amsObjects.light[name].spotLights = [spotLight1, spotLight2];

                        that.scene.add(that.amsObjects.light[name].scene);
                        that.scene.add(that.amsObjects.light[name].spotLights[0]);
                        that.scene.add(that.amsObjects.light[name].spotLights[0].target);
                        that.scene.add(that.amsObjects.light[name].spotLights[1]);
                        that.scene.add(that.amsObjects.light[name].spotLights[1].target);
                    })
                }

                updateLightStatus(object, message) {
                    object.status = message.body;
                    if(object.status.state === "on") {
                        object.spotLights[0].intensity = 3.0;
                        object.spotLights[1].intensity = 3.0;
                    }
                    else if(object.status.state === "off") {
                        object.spotLights[0].intensity = 0.01;
                        object.spotLights[1].intensity = 0.01;
                    }
                }

                updateShutterOpenPercentage(name, initialPositionZ, open_percentage) {
                    // open_percentage: 0.0~1.0
                    const object = this.amsObjects.shutter[name];
                    if(typeof object !== "undefined") {
                        const scene = object.scene;
                        if( scene !== null ) {
                            scene.children[2].position.z = initialPositionZ + 2400000 * 0.001 * open_percentage;  // 1.0: 0, 0.75:600, 0.5:1200, 0.25:1800, 0.0:2400
                            scene.children[2].scale.z = Math.max(0.00001, 1.0 - open_percentage);
                        }
                    }
                }

                onShutterConfigMessage(topic, message) {
                    const shutterConfig = message;
                    const from_target_code = Topic.get_from_target_code(topic);
                    this.amsObjects.shutter[from_target_code] = {
                        "config": shutterConfig,
                        "status": null,
                        "scene": null
                    };
                    this.addShutter(
                        "static/3ds/shutter.3ds", from_target_code, shutterConfig.body.pose.position, shutterConfig.body.pose.orientation.rpy.yaw,
                        {
                            "x": 0.00103, "y": 0.001, "z": 0.0009
                        },
                        0.0
                    );
                }

                addShutter(path, name, position, rotation_z, scale, open_percentage) {
                    const that = this;
                    this.tdsLoader.load(path, function (object) {
                        object.scale.set(scale.x, scale.y, scale.z);
                        object.setRotationFromAxisAngle(new THREE.Vector3(0, 0, 1), rotation_z);
                        object.position.set(position.x, position.y, position.z);
                        object.name = name;
                        that.amsObjects.shutter[name].scene = object;
                        that.scene.add(that.amsObjects.shutter[name].scene);
                    })
                }

                onShutterStatusMessage(topic, message) {
                    const shutterStatus = message;
                    const from_target_code = Topic.get_from_target_code(topic);
                    const shutterObject = this.amsObjects.shutter[from_target_code];
                    if(typeof shutterObject !== "undefined") {
                        this.amsObjects.shutter[from_target_code]["status"] = shutterStatus;
                        let open_percentage = 0.0;
                        switch(shutterStatus.body.state){
                            case "opened":
                                open_percentage = 1.0;
                                break;
                            case "opening":
                                open_percentage = shutterStatus.percentage;
                                break;
                            case "closed":
                                open_percentage = 0.0;
                                break;
                            case "closing":
                                open_percentage = shutterStatus.percentage;
                                break;
                            default:
                                open_percentage = 0.0;
                                break;
                        }

                        this.updateShutterOpenPercentage(from_target_code, this.amsObjects.shutter[from_target_code].config.body.pose.position.z, open_percentage)
                    }
                    else {
                        const domain = Topic.get_domain(topic);
                        this.requestShutterConfig(domain, from_target_code);
                    }
                }

                requestShutterConfig(domain, from_target_code) {
                    const requestTopic = ["", domain, "dev_front/df1", from_target_code, "request/get_config"].join("/");
                    const message = {
                        "header": {
                            "id": "",
                            "time": time(),
                            "version": VERSION
                        }
                    };
                    this.pubSubClient.publish(requestTopic, message);
                }

                drawWaypoint() {
                    const sphere = new THREE.SphereBufferGeometry( 0.1, 16, 8 );
                    const waypoint = new THREE.Mesh( sphere, new THREE.MeshBasicMaterial( {
                        color: 0x00FF00
                    }));
                    waypoint.position.set(-3320.9229,-37462.1133,0.7666);
                    this.scene.add( waypoint );
                }

                drawAll() {
                    this.getViewTargetPosition();
                    this.getAMSMaps();
                    this.getPCDFileNames();

                    // this.drawWaypoint();

                    this.pubSubClient.start();
                }
            }

            const threeMap = new ThreeMap();
            threeMap.drawAll();
        </script>
    </body>
</html>
